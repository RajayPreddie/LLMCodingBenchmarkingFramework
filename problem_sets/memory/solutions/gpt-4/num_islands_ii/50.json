{
    "problem_identifier": "num_islands_ii",
    "model_identifier": "gpt-4",
    "prompt_identifier": "50",
    "solution_code": "from typing import List\n\nclass Solution:\n    def num_islands_ii(self, m: int, n: int, positions: List[List[int]]) -> List[int]:\n        # Union-Find Class\n        class UnionFind:\n            def __init__(self, m, n):\n                self.Count = 0 \n                self.Id = [-1] * (m * n) \n                \n            def add(self, p):\n                self.Id[p] = p  \n                self.Count += 1      \n                \n            def find(self, p):\n                while p != self.Id[p]:\n                    self.Id[p] = self.Id[self.Id[p]]\n                    p = self.Id[p]\n                return p    \n            \n            def union(self, p, q):\n                rootP, rootQ = map(self.find, (p, q))\n                if rootP != rootQ:           \n                    self.Id[rootQ] = rootP  \n                    self.Count -= 1          \n        \n        # Initialize results and UnionFind\n        results, uf, m, n = [], UnionFind(m, n), m, n  \n        # Directions for getting surround cells\n        directions = [(0, -1), (-1, 0), (0, 1), (1, 0)] \n        \n        for p in map(lambda x: n * x[0] + x[1], positions):\n            if uf.Id[p] == -1:          \n                uf.add(p)\n                \n                # Union surrounding lands\n                for d in directions:\n                    np = p + d[0] * n + d[1] \n                    if 0 <= np < m * n and uf.Id[np] != -1:\n                        uf.union(p, np)\n                        \n                results.append(uf.Count)\n                \n        return results",
    "feedback": null
}